# 람다로 프로그래밍

> 람다 `lambda`는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다

람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다.

---
## 람다 식과 멤버 참조

자바에서는 익명 내부 클래스를 통해 이런 목적을 달성했다.

익명 내부 클래스를 사용하면 코드를 함수에 넘기거나 변수에 저장할 수 있기는 하지만 상당히 번거롭다.

이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결한다.

클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다.

람다 식을 사용하면 코드가 더욱 더 간결해진다.

람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다.

그런데 이거 자바8에서도 람다식을 통해서 되서 의미가 있나 싶은데...

### 람다와 컬렉션

람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를 제공하기 힘들다.

자바에서 스트림 연산자를 통해 처리함...?

자바 컬렉션에 대해 (자바 8 이전에) 수행하던 대부분의 작업은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선할 수 있다.

### 람다식의 문법

![img.png](static/images/image01.png)

코틀린의 람다식 문법

코틀린 람다는 `{ }` 중괄호로 항상 둘러싸여 있다.

```kotlin
// 변수에 람다 저장
val sum = { x: Int, y: Int -> x + y }

println(sum(1,2)) // 변수에 저장된 람다 호출

{ println(42) }() // 람다식 선언과 바로 직접 호출, 별 의미도 없음

run { println(42) } // 위와 같은 역활, run 을 사용해 람다식 선언
```

코틀린에서는 함수를 일급객체로 쓰며, 함수가 인자 목록의 마지막으로 람다를 쓸 경우 밖으로 뺄수 있음

람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it 을 바로 쓸 수 있다.

본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다.

### 현재 영역에 있는 변수에 접근

자바 메소드 안에서 무명 내부 클래스를 정의할 때 메소드의 로컬 변수를 무명 내부
클래스에서 사용할 수 있다. 람다 안에서도 같은 일을 할 수 있다.

람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.

**자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점**

코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다

어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.

포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.

파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다.

파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다

### 변수 포획

자바에서는 파이널 변수만 포획 가능하나

변경 가능한 변수를 포획할 경우, 배열을 선언하거나, 해당 변수를 필드로 하는 클래스 선언

( 배열이나 클래스의 인스턴스에 대한 참조를 `final` 로 선언하면 포획 가능)

코틀린에서 이런방법 필요 없이 가능하다

람다가 파이널 변수를 포획하면 그 변수의 값이 복사함 (자바와 동일)

변경 가능한 변수 포획시 벼수를 `Ref` 클래스 인스턴스에 넣고 , 람다 식내에서는 `Ref` 인스턴스의 필드를 변경 가능.

### 멤버 참조

코틀린에서는 자바 8과 마찬가지로 함수를 값으로 바꿀 수 있다.

`::` 를 사용하는 식을 멤버 참조라고 부른다.

멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.